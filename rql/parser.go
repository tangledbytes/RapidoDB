package rql

import (
	"errors"
	"fmt"
	"strconv"
)

// Parser is the parser for RQL
type Parser struct {
	DisableHelpMsgs bool
}

func tokenFromKeyword(k keyword) token {
	return token{
		typ: keywordType,
		val: string(k),
	}
}

func tokenFromSymbol(s symbol) token {
	return token{
		typ: symbolType,
		val: string(s),
	}
}

func expectToken(tokens []*token, cursor uint, t token) bool {
	if cursor >= uint(len(tokens)) {
		return false
	}

	return t.equals(tokens[cursor])
}

func parseToken(tokens []*token, initialCursor uint, typ tokenType) (*token, uint, bool) {
	cursor := initialCursor

	if cursor >= uint(len(tokens)) {
		return nil, initialCursor, false
	}

	current := tokens[initialCursor]
	if current.typ == typ {
		return current, cursor + 1, true
	}

	return nil, initialCursor, false
}

func helpMessage(tokens []*token, cursor uint, msg string) string {
	var c *token
	if cursor < uint(len(tokens)) {
		c = tokens[cursor]
	} else {
		c = tokens[cursor-1]
	}

	return fmt.Sprintf("[%d,%d]: %s, got: %s\n", c.loc.line, c.loc.col, msg, c.val)
}

// Parse parses the tokens generated by the lexer and generates and AST
func Parse(source string) (*Ast, error) {
	tokens, err := lex(source)
	if err != nil {
		return nil, err
	}
	a := Ast{}
	cursor := uint(0)
	for cursor < uint(len(tokens)) {
		stmt, newCursor, ok, err := parseStatement(tokens, cursor, tokenFromSymbol(semicolonSymbol))
		if !ok {
			return nil, err
		}
		cursor = newCursor

		a.Statements = append(a.Statements, stmt)

		if err != nil {
			return &a, err
		}

		atLeastOneSemicolon := false
		for expectToken(tokens, cursor, tokenFromSymbol(semicolonSymbol)) {
			cursor++
			atLeastOneSemicolon = true
		}

		if !atLeastOneSemicolon {
			return nil, errors.New(helpMessage(tokens, cursor, "Expected semi-colon delimiter between statements"))
		}
	}

	return &a, nil
}

func parseStatement(tokens []*token, initialCursor uint, delimiter token) (*Statement, uint, bool, error) {
	cursor := initialCursor

	// Look for a SET statement
	set, newCursor, ok, err := parseSetStatement(tokens, cursor, delimiter)
	if ok {
		return &Statement{
			Typ:          SetType,
			SetStatement: set,
		}, newCursor, true, err
	}

	// Look for a GET statement
	get, newCursor, ok, err := parseGetStatement(tokens, cursor, delimiter)
	if ok {
		return &Statement{
			Typ:          GetType,
			GetStatement: get,
		}, newCursor, true, err
	}

	// Look for a DEL statement
	del, newCursor, ok, err := parseDeleteStatement(tokens, cursor, delimiter)
	if ok {
		return &Statement{
			Typ:             DeleteType,
			DeleteStatement: del,
		}, newCursor, true, err
	}

	// Look for a AUTH statement
	auth, newCursor, ok, err := parseAuthStatement(tokens, cursor, delimiter)
	if ok {
		return &Statement{
			Typ:           AuthType,
			AuthStatement: auth,
		}, newCursor, true, err
	}

	// Look for a WIPE statement
	wipe, newCursor, ok, err := parseWipeStatement(tokens, cursor, delimiter)
	if ok {
		return &Statement{
			Typ:           WipeType,
			WipeStatement: wipe,
		}, newCursor, true, err
	}

	// Look for a REGUSER statement
	reguser, newCursor, ok, err := parseRegUserStatement(tokens, cursor, delimiter)
	if ok {
		return &Statement{
			Typ:              RegUserType,
			RegUserStatement: reguser,
		}, newCursor, true, err
	}

	// Look for a PING statement
	ping, newCursor, ok, err := parsePingStatement(tokens, cursor, delimiter)
	if ok {
		return &Statement{
			Typ:           PingType,
			PingStatement: ping,
		}, newCursor, true, err
	}
	return nil, initialCursor, false, nil
}

func parseSetStatement(tokens []*token, initialCursor uint, delimiter token) (*SetStatement, uint, bool, error) {
	// SET <key> <value> [expiry] [TODO: ADD COMPLEX EXPRESSIONS SUPPORT]
	cursor := initialCursor

	// Look for the SET keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(setKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	// Look for the key name
	key, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, initialCursor, true, errors.New(helpMessage(tokens, cursor, "Expected a key name"))
	}
	cursor = newCursor

	// Look for the value
	val, newCursor, ok := parseExpression(tokens, cursor)
	if !ok {
		return nil, initialCursor, true, errors.New(helpMessage(tokens, cursor, "Expected a value"))
	}
	cursor = newCursor

	// Search for optional expiry
	exp, newCursor, ok := parseToken(tokens, cursor, numericType)
	if !ok {
		return &SetStatement{
			key: key.val,
			val: val.val,
		}, cursor, true, nil
	}

	expVal, err := strconv.ParseUint(exp.val, 10, 32)
	if err != nil {
		return nil, cursor, true, errors.New(helpMessage(tokens, cursor, "Invalid expiry provided"))
	}
	cursor = newCursor

	return &SetStatement{key.val, val.val, uint(expVal)}, cursor, true, nil
}

func parseGetStatement(tokens []*token, initialCursor uint, delimiter token) (*GetStatement, uint, bool, error) {
	// GET key1 key2 ...
	cursor := initialCursor

	// Look for the GET keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(getKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	keys := []string{}

	for {
		key, newCursor, ok := parseToken(tokens, cursor, identifierType)
		if !ok {
			// Check if the token is the delimiter
			if !expectToken(tokens, newCursor, delimiter) {
				return nil, newCursor, true, errors.New(helpMessage(tokens, cursor, "Invalid key name"))
			}

			return &GetStatement{keys}, cursor, true, nil
		}

		keys = append(keys, key.val)
		cursor = newCursor
	}
}

func parseDeleteStatement(tokens []*token, initialCursor uint, delimiter token) (*DeleteStatement, uint, bool, error) {
	// DEL key1 key2 ...
	cursor := initialCursor

	// Look for the DEL keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(delKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	keys := []string{}

	for {
		key, newCursor, ok := parseToken(tokens, cursor, identifierType)
		if !ok {
			// Check if the token is the delimiter
			if !expectToken(tokens, newCursor, delimiter) {
				return nil, newCursor, true, errors.New(helpMessage(tokens, cursor, "Invalid key name"))
			}

			return &DeleteStatement{keys}, cursor, true, nil
		}

		keys = append(keys, key.val)
		cursor = newCursor
	}
}

func parseAuthStatement(tokens []*token, initialCursor uint, delimiter token) (*AuthStatement, uint, bool, error) {
	// AUTH <username> <password>;
	cursor := initialCursor

	// Look for the AUTH keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(authKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	// Look for the username
	username, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, cursor, true, errors.New(helpMessage(tokens, cursor, "username not found"))
	}
	cursor = newCursor

	// Look for the password
	password, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, cursor, true, errors.New(helpMessage(tokens, cursor, "password not found"))
	}
	cursor = newCursor

	return &AuthStatement{username.val, password.val}, cursor, true, nil
}

func parseWipeStatement(tokens []*token, initialCursor uint, delimiter token) (*WipeStatement, uint, bool, error) {
	// WIPE;
	cursor := initialCursor

	// Loof for the WIPE keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(wipeKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	return &WipeStatement{}, cursor, true, nil
}

func parseRegUserStatement(tokens []*token, initialCursor uint, delimiter token) (*RegUserStatement, uint, bool, error) {
	// REGUSER <username> <password> [access_level];
	cursor := initialCursor

	// Look for the REGUSER keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(reguserKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	// Look for the username
	username, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, initialCursor, true, errors.New(helpMessage(tokens, cursor, "Expected a username"))
	}
	cursor = newCursor

	// Look for the username
	password, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, initialCursor, true, errors.New(helpMessage(tokens, cursor, "Expected a password"))
	}
	cursor = newCursor

	// Search for optional accesslevel
	exp, newCursor, ok := parseToken(tokens, cursor, numericType)
	if !ok {
		return &RegUserStatement{
			username: username.val,
			password: password.val,
		}, cursor, true, nil
	}

	accesslevel, err := strconv.ParseUint(exp.val, 10, 16)
	if err != nil {
		return nil, cursor, true, errors.New(helpMessage(tokens, cursor, "Invalid access level provided"))
	}
	cursor = newCursor

	return &RegUserStatement{username.val, password.val, uint(accesslevel)}, cursor, true, nil
}

func parsePingStatement(tokens []*token, initialCursor uint, delimiter token) (*PingStatement, uint, bool, error) {
	// PING ON <OPERATION>
	cursor := initialCursor

	// Look for "PING" keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(pingKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++
	on := true
	// Look for "ON" or "OFF" keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(onKeyword)) {
		on = false
		if !expectToken(tokens, cursor, tokenFromKeyword(offKeyword)) {
			return &PingStatement{}, cursor, true, errors.New(helpMessage(tokens, cursor, "Expected ON or OFF after PING"))
		}
	}
	cursor++

	// Look for any of the keywords from "GET", "SET", "DEL", "WIPE"
	keywords := []keyword{setKeyword, getKeyword, delKeyword, wipeKeyword}

	for _, kw := range keywords {
		tk := tokenFromKeyword(kw)
		if expectToken(tokens, cursor, tk) {
			cursor++
			return &PingStatement{on, tk.val}, cursor, true, nil
		}
	}

	return nil, cursor, true, errors.New(helpMessage(tokens, cursor, "Expected a valid operation"))
}

func parseExpression(tokens []*token, initialCursor uint) (*token, uint, bool) {
	cursor := initialCursor

	types := []tokenType{identifierType, numericType, stringType}
	for _, typ := range types {
		t, newCursor, ok := parseToken(tokens, cursor, typ)
		if ok {
			return t, newCursor, true
		}
	}

	return nil, initialCursor, false
}
